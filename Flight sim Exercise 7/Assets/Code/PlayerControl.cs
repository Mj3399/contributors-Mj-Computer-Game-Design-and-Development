using System;
using UnityEditorInternal;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Control code for the the player's game object.
/// Very approximate simulation of flight dynamics.
/// </summary>
public class PlayerControl : MonoBehaviour {
    /// <summary>
    /// Coefficient of draft for head winds
    /// </summary>
    [Header("Aerodynamic coefficients")]
    public float ForwardDragCoefficient = 0.01f;
    /// <summary>
    /// Drag coefficient for winds blowing up/down across wings
    /// </summary>
    public float VerticalDragCoefficient = 0.5f;
    /// <summary>
    /// Lift generated by the wings
    /// </summary>
    public float LiftCoefficient = 0.01f;

    /// <summary>
    /// How far the plane can tilt around the X axis
    /// </summary>
    [Header("Movement Speeds")]
    public float PitchRange = 45f;
    /// <summary>
    /// How far the plane can rotate about the Z axis
    /// </summary>
    public float RollRange = 45;
    /// <summary>
    /// How fast the plane yaws for a given degree of roll.
    /// </summary>
    public float RotationalSpeed = 5f;
    /// <summary>
    /// Thrust generated when the throttle is pulled back all the way.
    /// </summary>
    public float MaximumThrust = 20f;

    /// <summary>
    /// Text element for displaying status information
    /// </summary>
    [Header("HUD")]
    public Text StatusDisplay;
    /// <summary>
    /// Text element for displaying game-over text
    /// </summary>
    public Text GameOverText;

    /// <summary>
    /// Cached copy of the player's RigidBody component
    /// </summary>
    private Rigidbody playerRB;


    /// <summary>
    /// Magic layer mask code for the updraft(s)
    /// </summary>
    const int UpdraftLayerMask = 1 << 8;


    #region Internal flight state
    /// <summary>
    /// Current yaw (rotation about the Y axis)
    /// </summary>
    private float yaw;
    /// <summary>
    /// Current pitch (rotation about the X axis)
    /// </summary>
    private float pitch;
    /// <summary>
    /// Current roll (rotation about the Z axis)
    /// </summary>
    private float roll;
    public int fk = 0;
    /// <summary>
    /// Current thrust (forward force provided by engines
    /// </summary>
    private float thrust;
#endregion

    /// <summary>
    /// Initialize component
    /// </summary>
    internal void Start() {
        playerRB = GetComponent<Rigidbody>();
        playerRB.velocity = transform.forward*3;
    
    }

    /// <summary>
    /// Show game-over display
    /// </summary>
    /// <param name="safe">True if we won, false if we crashed</param>
    private void OnGameOver(bool safe, int fk) {
        playerRB.velocity = Vector3.zero;
        playerRB.useGravity = false;
        playerRB.constraints = RigidbodyConstraints.FreezeAll;
        
        if (safe && fk ==0) {
            GameOverText.text = "You Win!";
            return;
        } 
        if(!safe && fk ==0){
            GameOverText.text = "OOPS";
            return;
        }
    }

    /// <summary>
    /// Display status information
    /// </summary>
    internal void OnGUI()
    {
        StatusDisplay.text = string.Format("Speed: {0:00.00}    altitude: {1:00.00}    Thrust {2:0.0}",
            playerRB.velocity.magnitude,
            transform.position.y,
            thrust);
    }

    void FixedUpdate()
    {
        var joyroll = Input.GetAxis("Horizontal") *RollRange;
        var joystickpitch = Input.GetAxis("Vertical")* PitchRange;
        

        //smoothing
        roll = Mathf.Lerp(roll, joyroll, 0.01f);
        // yaw += roll * RotationalSpeed * Time.fixedDeltaTime;
        yaw -= roll * RotationalSpeed * Time.fixedDeltaTime;

        pitch = Mathf.Lerp(pitch, joystickpitch, 0.01f);
        

        //yawpitchroll

        playerRB.MoveRotation(Quaternion.Euler(pitch, yaw, roll));

        //thrust
        thrust = Mathf.Clamp(Input.GetAxis("Thrust"), 0, 1) * MaximumThrust;
        playerRB.AddRelativeForce(0,0, thrust );

        //lift
        Vector3 vrel ;
        if(Physics.OverlapSphere(transform.position, 1, LayerMask.GetMask("Updrafts")) != null) {
            var sum = new Vector3 (0, 0, 0);
            var up = Physics.OverlapSphere(transform.position, 1, LayerMask.GetMask("Updrafts"));
            for (int i = 0; i < up.Length; i++)
            {
                sum += up[i].gameObject.GetComponent<Updraft>().WindVelocity;
            }
                
               
             vrel = sum - playerRB.velocity;

        }
        else
        {
           vrel = playerRB.velocity * -1;
        }
        

        float v = Vector3.Dot(vrel, transform.forward);
        float q = v*v;
        playerRB.AddForce(LiftCoefficient * q * transform.up);


        //drag
        var forw = Mathf.Sign(v) * ForwardDragCoefficient * q * transform.forward;


        float k = Vector3.Dot(vrel, transform.up);
        float kk = k * k;
        var ver = Mathf.Sign(k)* VerticalDragCoefficient*kk* transform.up;
        var drag = ver +forw;
        playerRB.AddForce(drag);
        

    }

    private void OnCollisionEnter(Collision collision)
    {
        if(collision.collider.GetComponent<LandingPlatform>() != null)
        {
           
            
            OnGameOver(collision.relativeVelocity.magnitude < collision.collider.GetComponent<LandingPlatform>().MaxLandingSpeed, fk);
            fk++;
        }
        else
        {
            OnGameOver(false, fk);
            fk++;
        }
        
    }
}
